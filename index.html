<!DOCTYPE html>
<html lang="en">
	<head>
		<title></title>
		<meta charset="utf-8">
		<meta name="generator" content="Three.js Editor">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: sans-serif;
				font-size: 11px;
				background-color: white;
				margin: 0px;
			}
			canvas {
				display: block;
			}
		</style>
	</head>
	<body ontouchstart="">
		<script src="https://cdn.jsdelivr.net/npm/three@0.122.0/build/three.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/three@0.122.0/examples/js/controls/OrbitControls.min.js"></script>
		<script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/three@0.122.0/examples/js/controls/DragControls.js"></script>
		
		<script>
			const material = {
				v1: new THREE.MeshLambertMaterial({ color: 0x0095DD }),
				v2: new THREE.MeshLambertMaterial({ color: 0x0A4BCC }),
				v3: new THREE.MeshLambertMaterial({ color: 0xB999CC })
			}
		
			let newShape;

			const loader = new THREE.GLTFLoader();
			const renderer = new THREE.WebGLRenderer({
				antialias: true,
				alpha: true
			});
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			let selectedObject = null;
			const raycaster = new THREE.Raycaster();
			const pointer = new THREE.Vector2();

			const scene = new THREE.Scene();
			group = new THREE.Group();
			scene.add(group);

			//Camera Set
			const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100000);
			camera.position.set(5, 5, 10);
			camera.lookAt(scene.position);

			const controls = new THREE.OrbitControls(camera, renderer.domElement);

			var light = new THREE.HemisphereLight(0xFFFFFF, 0xFFFFFF, 1);
			light.position.set(0, -0.5, -1)
			scene.add(light);
			
			ambientLight = new THREE.AmbientLight(0x000000);
			scene.add(ambientLight);

			//controls.update() must be called after any manual changes to the camera's transform
			//camera.position.set(0, 0, 3);

			window.addEventListener('resize', onWindowResize);
			document.addEventListener('pointermove', onPointerMove);

			controls.update();
			

			function animate() {
				/*
				requestAnimationFrame(animate);
				controls.update();
				renderer.render(scene, camera);
				renderer.setClearColor(0xffffff, 0);
				*/
				
				renderer.render(scene, camera);
				requestAnimationFrame(animate);
				
			}

			animate();

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);

			}

			function onPointerMove(event) {
				/*
				if (selectedObject) {

					selectedObject.material.color.set('#69f');
					selectedObject = null;

				}
				*/

				if (scene.children[0].children.length > 0) {
					scene.children[0].children[0].rotation.x = Math.sin( (camera.position.x + camera.position.y ) * 0.1 + 5)
					scene.children[0].children[1].rotation.x = Math.sin((camera.position.x + camera.position.y) * 0.1 + 3)
					scene.children[0].children[2].rotation.x = Math.sin((camera.position.x + camera.position.y) * 0.1 + 2)
				}
				
				pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
				pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

				raycaster.setFromCamera(pointer, camera);

				const intersects = raycaster.intersectObject(group, true);

				if (intersects.length > 0) {

					const res = intersects.filter(function (res) {

						return res && res.object;

					})[0];

					/*
					if (res && res.object) {

						selectedObject = res.object;
						selectedObject.material.color.set('#f00');

					}
					*/

				}

			}


			loader.load(
					// resource URL
					'theme.glb',
					// called when the resource is loaded
					function (gltf) {
						const theme = {
							v1: gltf.scene.children[3].geometry,
							v2: gltf.scene.children[4].geometry,
							v3: gltf.scene.children[5].geometry,
						};

						newShape = {
							v1: new THREE.Mesh(theme.v1, material.v1),
							v2: new THREE.Mesh(theme.v2, material.v2),
							v3: new THREE.Mesh(theme.v3, material.v3),
						}

						newShape.v1.position.set(3, 3, 5);
						newShape.v1.scale.set(5, 5, 5);
						group.add(newShape.v1);

						
						newShape.v2.material.rotation = Math.PI / 3 * 4;
						newShape.v2.position.set(4, -2, 2);
						//newShape.v2.center.set(0.5, 0);
						newShape.v2.scale.set(4, 4, 4);
						group.add(newShape.v2);

						const group2 = new THREE.Object3D();
						group2.scale.set(2, 2, 2);
						group.add(group2);

						newShape.v3.scale.set(3, 3, 3);
						group2.add(newShape.v3);
					},
					// called while loading is progressing
					function (xhr) {
						console.log((xhr.loaded / xhr.total * 100) + '% loaded');
					},
					// called when loading has errors
					function (error) {
						console.log('An error happened');
					}
				);

		</script>
	</body>
</html>
